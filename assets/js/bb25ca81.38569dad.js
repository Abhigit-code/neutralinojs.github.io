"use strict";(self.webpackChunkneutralinojs_github_io=self.webpackChunkneutralinojs_github_io||[]).push([[1209],{7381:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>l});var i=n(4848),r=n(8453);const s={title:"Security"},o=void 0,a={id:"contributing/security",title:"Security",description:"Security is typically a hidden layer in software systems, but it is as crucial as all other elements in a",source:"@site/docs/contributing/security.md",sourceDirName:"contributing",slug:"/contributing/security",permalink:"/docs/contributing/security",draft:!1,unlisted:!1,editUrl:"https://github.com/neutralinojs/neutralinojs.github.io/edit/main/docs/contributing/security.md",tags:[],version:"current",frontMatter:{title:"Security"},sidebar:"docs",previous:{title:"Architecture",permalink:"/docs/contributing/architecture"},next:{title:"Code Style Guide",permalink:"/docs/contributing/code-style-guide"}},c={},l=[{value:"Port security and authentication",id:"port-security-and-authentication",level:2},{value:"Native API access control and authorization",id:"native-api-access-control-and-authorization",level:2}];function u(e){const t={a:"a",h2:"h2",img:"img",li:"li",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"Security is typically a hidden layer in software systems, but it is as crucial as all other elements in a\ngood quality software system. Application security is a user's right and a developer's responsibility for\npreventing various digital attacks. Also, the security-first design is a mandatory design principle for\nmodern software systems due to the increasing number of computer users."}),"\n",(0,i.jsx)(t.p,{children:"We use the following strategies to strengthen the framework's security layer."}),"\n",(0,i.jsx)(t.h2,{id:"port-security-and-authentication",children:"Port security and authentication"}),"\n",(0,i.jsxs)(t.p,{children:["Once you study the ",(0,i.jsx)(t.a,{href:"/docs/contributing/architecture",children:"Neutralinojs architecture"}),", you will notice that the framework frontend communicates with\nthe framework core via a WebSocket-based network port. Developers who know the operating system internals\nwill argue that the Neutralinojs framework is vulnerable due to the local port-based IPC."]}),"\n",(0,i.jsx)(t.p,{children:"Let's understand it this way. The network is undoubtedly vulnerable, but network security strategies make\nnetworks secure for every computer user\u2014that's how we trust the internet today. Similarly, Neutralinojs\nuses the One-Time-Token (OTT) strategy to prevent possible port scanning attacks."}),"\n",(0,i.jsx)(t.p,{children:"Here is how the Neutralinojs local port is secured:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"The Neutralinojs framework's authentication module generates the OTT during the initialization process and a\npart of the OTT is saved as Connection Token (CT) for WebSocket clients."}),"\n",(0,i.jsx)(t.li,{children:"When the user loads the client-library script, the framework sends the OTT only once."}),"\n",(0,i.jsx)(t.li,{children:"The client library stores the OTT in the local storage for future usage\u2014the framework never sends the OTT again to the frontend. Depending on the current application mode, the client library stores the OTT in either webview or web browser."}),"\n",(0,i.jsx)(t.li,{children:"The client library uses CT to establish a WebSocket connection with the framework."}),"\n",(0,i.jsx)(t.li,{children:"The OTT is used to verify every native API function call that comes from WebSocket clients (including the client-library)."}),"\n",(0,i.jsx)(t.li,{children:"The framework blocks WebSocket connections from remote URLs within window, browser, and Chrome modes."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"The following criteria need to be satisfied for executing an arbitrary API function via a malicious\nwebpage (local) or program:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"The specific malicious component needs to capture the OTT before the original application obtains the\nOTT from the framework core. This attacking strategy is not practical because of the fast application\nstartup and lack of faster ways to access operating system-level process status. Even though someone\nmanages to detect the application startup, the original application requests OTT before the malicious\nprogram (The framework sends OTT only once). On the other hand, malicious programs don't need Neutralinojs\nto damage your computer system, so use programs you trust."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Even the OTT request process is not possible with modern web browsers via remote pages due to CORS-like\nsecurity strategies. Also, we don't even enable the native API for remote pages due to strict application\nsecurity."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"If there is a way (there is no proven approach yet) to crack OTT, native API access controls protect the\nuser's computer."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"native-api-access-control-and-authorization",children:"Native API access control and authorization"}),"\n",(0,i.jsx)(t.p,{children:"The OTT strategy provides authentication for native API access by preventing\ninvalid/vulnerable client connections. The OTT grants access to the native API, but it doesn't give access\nto everything. Most modern popular application runtimes provide access to everything without proper access\ncontrol. In the Neutralinojs native API model, developers need to mention the APIs they need explicitly for\nbetter security."}),"\n",(0,i.jsx)(t.p,{children:"Developers can define API permission requirements via the native allowlist or blocklist features.\nThe Neutralinojs native API permission system provides authorization support by validating incoming\nrequests with the pre-defined permission matrices."}),"\n",(0,i.jsx)(t.p,{children:"Look at the following authentication/authorization diagram for more details:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:n(198).A+"",width:"691",height:"894"})}),"\n",(0,i.jsx)(t.p,{children:"Moreover, Neutralinojs extensions also securely receive WebSocket authentication details (OTT, CT, and port) via\nstandard input streams, so malicious programs can't obtain connectivity secrets by scanning your process list."}),"\n",(0,i.jsxs)(t.p,{children:["Read our ",(0,i.jsx)(t.a,{href:"https://github.com/neutralinojs/neutralinojs/security/policy",children:"security policy"}),"\nto learn how to handle security-related framework issues."]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},198:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/neutralinojs-security-b9e4b44bbfc16e3e354e6832a120948a.png"},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var i=n(6540);const r={},s=i.createContext(r);function o(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);