"use strict";(self.webpackChunkneutralinojs_github_io=self.webpackChunkneutralinojs_github_io||[]).push([[9095],{4805:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>l});var t=s(4848),o=s(8453);const i={title:"Extensions Overview"},a=void 0,r={id:"how-to/extensions-overview",title:"Extensions Overview",description:"The Neutralino framework provides a native API that allows users to perform various operating system-level operations such as accessing the filesystem, executing commands, and showing dialog boxes. While users may require additional native APIs like database connectors for building their applications, adding all of them to the core would make the framework bloated. Therefore, the framework offers a WebSocket-based extension system that enables users to extend the Neutralinojs API without having to build the framework from source.",source:"@site/docs/how-to/extensions-overview.md",sourceDirName:"how-to",slug:"/how-to/extensions-overview",permalink:"/docs/how-to/extensions-overview",draft:!1,unlisted:!1,editUrl:"https://github.com/neutralinojs/neutralinojs.github.io/edit/main/docs/how-to/extensions-overview.md",tags:[],version:"current",frontMatter:{title:"Extensions Overview"},sidebar:"docs",previous:{title:"Modes",permalink:"/docs/configuration/modes"},next:{title:"Auto Updater",permalink:"/docs/how-to/auto-updater"}},c={},l=[{value:"Defining the extensions",id:"defining-the-extensions",level:2},{value:"Enable the extensions feature",id:"enable-the-extensions-feature",level:2},{value:"Connecting an extension with Neutralinojs",id:"connecting-an-extension-with-neutralinojs",level:2},{value:"Sending a message from app to an extension",id:"sending-a-message-from-app-to-an-extension",level:2},{value:"Sending a message from the extension to app",id:"sending-a-message-from-the-extension-to-app",level:2},{value:"Terminating an extension instance",id:"terminating-an-extension-instance",level:2},{value:"Using Neutralinojs from your source files",id:"using-neutralinojs-from-your-source-files",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"The Neutralino framework provides a native API that allows users to perform various operating system-level operations such as accessing the filesystem, executing commands, and showing dialog boxes. While users may require additional native APIs like database connectors for building their applications, adding all of them to the core would make the framework bloated. Therefore, the framework offers a WebSocket-based extension system that enables users to extend the Neutralinojs API without having to build the framework from source."}),"\n",(0,t.jsx)(n.p,{children:"The extensions API provides the flexibility to write custom backend code for your application using any programming language. Furthermore, the extensions API allows you to include the Neutralinojs process as a part of any source file."}),"\n",(0,t.jsx)(n.h2,{id:"defining-the-extensions",children:"Defining the extensions"}),"\n",(0,t.jsxs)(n.p,{children:["First, you need to define extensions you use in ",(0,t.jsx)(n.code,{children:"neutralinojs.config.json"})," with the following structure."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'"extensions": [\n    {\n        "id": "js.neutralino.sampleextension",\n        "commandLinux": "${NL_PATH}/extensions/binary/linux/ext_bin",\n        "commandDarwin": "${NL_PATH}/extensions/binary/mac/ext_bin",\n        "commandWindows": "${NL_PATH}/extensions/binary/win/ext_bin.exe"\n    },\n    {\n        "id": "js.neutralino.binaryextension",\n        "command": "node ${NL_PATH}/extensions/binary/main.js",\n    }\n]\n'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"id"})," String: A unique key to identify each extension. This id cannot contain any characters except for letters, numbers, and periods."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"command"})," String (optional): A cross-platform command to start the extension. Eg: ",(0,t.jsx)(n.code,{children:"node ${NL_PATH}/extensions/binary/main.js"}),"\nwill work on every platform."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"commandLinux"})," String (optional): Extension startup command for Linux."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"commandDarwin"})," String (optional): Extension startup command for macOS."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"commandWindows"})," String (optional): Extension startup command for Windows."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"enable-the-extensions-feature",children:"Enable the extensions feature"}),"\n",(0,t.jsx)(n.p,{children:"The extensions API is disabled by default. Enable extensions by adding the following setting to your app config."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'"enableExtensions": true\n'})}),"\n",(0,t.jsx)(n.h2,{id:"connecting-an-extension-with-neutralinojs",children:"Connecting an extension with Neutralinojs"}),"\n",(0,t.jsx)(n.p,{children:"As you already noticed, an extension is just a separate process. Neutralinojs starts spawning extension instances\nduring the framework bootstrap process and initiates each extension process by sending the following JSON object via\nstandard input streams:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "nlPort": "",\n  "nlToken": "",\n  "nlConnectToken": "",\n  "nlExtensionId": ""\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"The above JSON properties contains connectivity information as follows:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"nlPort"}),": port of the Neutralinojs server."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"nlToken"}),": Access token to use the native API."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"nlConnectToken"}),": A token that extension should send during WebSocket connection initialization."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"nlExtensionId"}),": Extension identifier."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Now, you can connect with the Neutralinojs server with the above details. Use the following WebSocket\nURL to initiate a new WebSocket connection."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"ws://localhost:{port}?extensionId={extensionId}&connectToken={connectToken}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"sending-a-message-from-app-to-an-extension",children:"Sending a message from app to an extension"}),"\n",(0,t.jsx)(n.p,{children:"The extensions API uses an event-based messaging protocol. Every message uses the following JSON structure."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "event": "<event_name>",\n  "data": {}\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Use the built-in extensions API to send a message to any extension, as shown below."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"let extension = 'js.neutralino.sampleextension';\nlet event = 'helloExtension';\nlet data = {\n  testValue: 10,\n};\n\nawait Neutralino.extensions.dispatch(extension, event, data);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The above code snippet sends a message to the ",(0,t.jsx)(n.code,{children:"js.neutralino.sampleextension"})," extension instance. You can send\nmessages to extensions with the ",(0,t.jsx)(n.code,{children:"dispatch"})," function anytime. If you send a message before the extension connects\nwith the main process, the Neutralinojs client library queues and sends it when the target extension's connection is\nestablished. In other words, you don't need to worry about extensions' status when you send messages to\nextensions."]}),"\n",(0,t.jsx)(n.h2,{id:"sending-a-message-from-the-extension-to-app",children:"Sending a message from the extension to app"}),"\n",(0,t.jsx)(n.p,{children:"When you connect your extensions with the Neutralinojs main process, you can call the native API by sending\nWebSocket messages to the Neutralinojs process directly. Neutralinojs server processes messages based on the\nfollowing format."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "id": "<id>",\n  "method": "<method>",\n  "accessToken": "<token>",\n  "data": {}\n}\n'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"id"})," String: A ",(0,t.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Universally_unique_identifier",children:"UUID"})," v4 string."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"method"})," String: Native method name. Eg: ",(0,t.jsx)(n.code,{children:"window.setTitle"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"accessToken"})," String: Access token generated by the Neutralinojs server."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"data"})," Object (optional): Parameters for the native method."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["You can invoke the ",(0,t.jsx)(n.code,{children:"app.broadcast"})," native method to send messages to all app instances. Register a callback\nwith the ",(0,t.jsx)(n.code,{children:"events.on"})," in the application code to receive the message send by the extension process."]}),"\n",(0,t.jsx)(n.h2,{id:"terminating-an-extension-instance",children:"Terminating an extension instance"}),"\n",(0,t.jsx)(n.p,{children:"When Neutralino exits, it does not send kill signals to all extension instances. Therefore, it is necessary to stop the extension process when the WebSocket-based IPC (Inter-Process Communication) closes. The following Node.js extension code shows how to do this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'const fs = require(\'fs\');\nconst process = require(\'process\');\nconst WS = require(\'websocket\').w3cwebsocket;\nconst { v4: uuidv4 } = require(\'uuid\');\nconst chalk = require(\'chalk\');\n\n// Obtain required params to start a WS connection from stdIn.\nconst processInput = JSON.parse(fs.readFileSync(process.stdin.fd, \'utf-8\'));\nconst NL_PORT = processInput.nlPort;\nconst NL_TOKEN = processInput.nlToken;\nconst NL_CTOKEN = processInput.nlConnectToken;\nconst NL_EXTID = processInput.nlExtensionId;\n\nconst client = new WS(\n  `ws://localhost:${NL_PORT}?extensionId=${NL_EXTID}&connectToken=${NL_CTOKEN}`\n);\n\nclient.onerror = () => log("Connection error!", "ERROR");\nclient.onopen = () => log("Connected");\nclient.onclose = () => process.exit();\n\nclient.onmessage = (e) => {\n  const { event, data } = JSON.parse(e.data);\n\n  if (event === "eventToExtension") {\n    log(data);\n\n    client.send(\n      JSON.stringify({\n        id: uuidv4(),\n        method: "app.broadcast",\n        accessToken: NL_TOKEN,\n        data: { event: "eventFromExtension", data: "Hello app!" },\n      })\n    );\n  }\n};\n\nfunction log(message, type = "INFO") {\n  const logLine = `[${NL_EXTID}]: ${chalk[\n    type === "INFO" ? "green" : "red"\n  ](type)} ${message}`;\n  console[type === "INFO" ? "log" : "error"](logLine);\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"This code implements a simple Node.js extension for Neutralinojs, which establishes a\nWebSocket connection to the Neutralinojs server and handles incoming messages from the server.\nIt also sends a message to the server using the client.send method when it receives a specific event\nfrom the server."}),"\n",(0,t.jsxs)(n.p,{children:["For more information on how to terminate an extension instance, you can refer to the sample extension source.\n",(0,t.jsx)(n.a,{href:"https://github.com/neutralinojs/neutralinojs/tree/main/bin/extensions/sampleextension",children:"https://github.com/neutralinojs/neutralinojs/tree/main/bin/extensions/sampleextension"})]}),"\n",(0,t.jsx)(n.h2,{id:"using-neutralinojs-from-your-source-files",children:"Using Neutralinojs from your source files"}),"\n",(0,t.jsx)(n.p,{children:"The above approach helps you to extend Neutralinojs API with a custom backend code. Neutralinojs process can\nspawn multiple extensions as child processes and communicate with the internal messaging protocol. On the other\nhand, you can spawn Neutralinojs processes from your own processes and communicate with the same messaging\nprotocol. Using this approach, it's possible to write Neutralinojs apps with any backend language."}),"\n",(0,t.jsx)(n.p,{children:"You can obtain authentication details for the Neutralinojs process by setting your config as below."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'"exportAuthInfo": true\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The above setting exports authentication details to ",(0,t.jsx)(n.code,{children:"${NL_PATH}/.tmp/auth_info.json"})," with the following format."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "nlPort": "<port>",\n  "nlToken": "<token>",\n  "nlConnectToken": "<connect_token>"\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Connect with the Neutralinojs process by using the extension API as usual with the extension identifier\nyou used in the application configuration file."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>r});var t=s(6540);const o={},i=t.createContext(o);function a(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);